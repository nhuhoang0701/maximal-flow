{"filter":false,"title":"main.py","tooltip":"/main.py","undoManager":{"mark":1,"position":1,"stack":[[{"start":{"row":0,"column":0},"end":{"row":104,"column":0},"action":"insert","lines":["# Python program for implementation","# of Ford Fulkerson algorithm","from collections import defaultdict","","# This class represents a directed graph","# using adjacency matrix representation","class Graph:","","\tdef __init__(self, graph):","\t\tself.graph = graph # residual graph","\t\tself. ROW = len(graph)","\t\t# self.COL = len(gr[0])","","\t'''Returns true if there is a path from source 's' to sink 't' in","\tresidual graph. Also fills parent[] to store the path '''","","\tdef BFS(self, s, t, parent):","","\t\t# Mark all the vertices as not visited","\t\tvisited = [False]*(self.ROW)","","\t\t# Create a queue for BFS","\t\tqueue = []","","\t\t# Mark the source node as visited and enqueue it","\t\tqueue.append(s)","\t\tvisited[s] = True","","\t\t# Standard BFS Loop","\t\twhile queue:","","\t\t\t# Dequeue a vertex from queue and print it","\t\t\tu = queue.pop(0)","","\t\t\t# Get all adjacent vertices of the dequeued vertex u","\t\t\t# If a adjacent has not been visited, then mark it","\t\t\t# visited and enqueue it","\t\t\tfor ind, val in enumerate(self.graph[u]):","\t\t\t\tif visited[ind] == False and val > 0:","\t\t\t\t\t# If we find a connection to the sink node,","\t\t\t\t\t# then there is no point in BFS anymore","\t\t\t\t\t# We just have to set its parent and can return true","\t\t\t\t\tqueue.append(ind)","\t\t\t\t\tvisited[ind] = True","\t\t\t\t\tparent[ind] = u","\t\t\t\t\tif ind == t:","\t\t\t\t\t\treturn True","","\t\t# We didn't reach sink in BFS starting","\t\t# from source, so return false","\t\treturn False","","","\t# Returns the maximum flow from s to t in the given graph","\tdef FordFulkerson(self, source, sink):","","\t\t# This array is filled by BFS and to store path","\t\tparent = [-1]*(self.ROW)","","\t\tmax_flow = 0 # There is no flow initially","","\t\t# Augment the flow while there is path from source to sink","\t\twhile self.BFS(source, sink, parent) :","","\t\t\t# Find minimum residual capacity of the edges along the","\t\t\t# path filled by BFS. Or we can say find the maximum flow","\t\t\t# through the path found.","\t\t\tpath_flow = float(\"Inf\")","\t\t\ts = sink","\t\t\twhile(s != source):","\t\t\t\tpath_flow = min (path_flow, self.graph[parent[s]][s])","\t\t\t\ts = parent[s]","","\t\t\t# Add path flow to overall flow","\t\t\tmax_flow += path_flow","","\t\t\t# update residual capacities of the edges and reverse edges","\t\t\t# along the path","\t\t\tv = sink","\t\t\twhile(v != source):","\t\t\t\tu = parent[v]","\t\t\t\tself.graph[u][v] -= path_flow","\t\t\t\tself.graph[v][u] += path_flow","\t\t\t\tv = parent[v]","","\t\treturn max_flow","","","# Create a graph given in the above diagram","","graph = [[0, 16, 13, 0, 0, 0],","\t\t[0, 0, 10, 12, 0, 0],","\t\t[0, 4, 0, 0, 14, 0],","\t\t[0, 0, 9, 0, 0, 20],","\t\t[0, 0, 0, 7, 0, 4],","\t\t[0, 0, 0, 0, 0, 0]]","","g = Graph(graph)","","source = 0; sink = 5","","print (\"The maximum possible flow is %d \" % g.FordFulkerson(source, sink))","","# This code is contributed by Neelam Yadav",""],"id":1}],[{"start":{"row":0,"column":0},"end":{"row":104,"column":0},"action":"remove","lines":["# Python program for implementation","# of Ford Fulkerson algorithm","from collections import defaultdict","","# This class represents a directed graph","# using adjacency matrix representation","class Graph:","","\tdef __init__(self, graph):","\t\tself.graph = graph # residual graph","\t\tself. ROW = len(graph)","\t\t# self.COL = len(gr[0])","","\t'''Returns true if there is a path from source 's' to sink 't' in","\tresidual graph. Also fills parent[] to store the path '''","","\tdef BFS(self, s, t, parent):","","\t\t# Mark all the vertices as not visited","\t\tvisited = [False]*(self.ROW)","","\t\t# Create a queue for BFS","\t\tqueue = []","","\t\t# Mark the source node as visited and enqueue it","\t\tqueue.append(s)","\t\tvisited[s] = True","","\t\t# Standard BFS Loop","\t\twhile queue:","","\t\t\t# Dequeue a vertex from queue and print it","\t\t\tu = queue.pop(0)","","\t\t\t# Get all adjacent vertices of the dequeued vertex u","\t\t\t# If a adjacent has not been visited, then mark it","\t\t\t# visited and enqueue it","\t\t\tfor ind, val in enumerate(self.graph[u]):","\t\t\t\tif visited[ind] == False and val > 0:","\t\t\t\t\t# If we find a connection to the sink node,","\t\t\t\t\t# then there is no point in BFS anymore","\t\t\t\t\t# We just have to set its parent and can return true","\t\t\t\t\tqueue.append(ind)","\t\t\t\t\tvisited[ind] = True","\t\t\t\t\tparent[ind] = u","\t\t\t\t\tif ind == t:","\t\t\t\t\t\treturn True","","\t\t# We didn't reach sink in BFS starting","\t\t# from source, so return false","\t\treturn False","","","\t# Returns the maximum flow from s to t in the given graph","\tdef FordFulkerson(self, source, sink):","","\t\t# This array is filled by BFS and to store path","\t\tparent = [-1]*(self.ROW)","","\t\tmax_flow = 0 # There is no flow initially","","\t\t# Augment the flow while there is path from source to sink","\t\twhile self.BFS(source, sink, parent) :","","\t\t\t# Find minimum residual capacity of the edges along the","\t\t\t# path filled by BFS. Or we can say find the maximum flow","\t\t\t# through the path found.","\t\t\tpath_flow = float(\"Inf\")","\t\t\ts = sink","\t\t\twhile(s != source):","\t\t\t\tpath_flow = min (path_flow, self.graph[parent[s]][s])","\t\t\t\ts = parent[s]","","\t\t\t# Add path flow to overall flow","\t\t\tmax_flow += path_flow","","\t\t\t# update residual capacities of the edges and reverse edges","\t\t\t# along the path","\t\t\tv = sink","\t\t\twhile(v != source):","\t\t\t\tu = parent[v]","\t\t\t\tself.graph[u][v] -= path_flow","\t\t\t\tself.graph[v][u] += path_flow","\t\t\t\tv = parent[v]","","\t\treturn max_flow","","","# Create a graph given in the above diagram","","graph = [[0, 16, 13, 0, 0, 0],","\t\t[0, 0, 10, 12, 0, 0],","\t\t[0, 4, 0, 0, 14, 0],","\t\t[0, 0, 9, 0, 0, 20],","\t\t[0, 0, 0, 7, 0, 4],","\t\t[0, 0, 0, 0, 0, 0]]","","g = Graph(graph)","","source = 0; sink = 5","","print (\"The maximum possible flow is %d \" % g.FordFulkerson(source, sink))","","# This code is contributed by Neelam Yadav",""],"id":2}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":0,"column":0},"end":{"row":0,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1650749494387,"hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709"}